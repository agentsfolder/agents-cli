use std::collections::BTreeMap;
use std::path::{Path, PathBuf};

use crate::fsutil;
use crate::model::OutputFormat;
use crate::outputs::OutputPlan;
use crate::stamps::parse_stamp;

use super::{ApplyReport, Backend, BackendError, BackendSession, ConflictDetail, ConflictReason, RenderedOutput};

#[derive(Debug, Default, Clone)]
pub struct MaterializeBackend;

impl Backend for MaterializeBackend {
    fn prepare(&self, repo_root: &Path, plan: &OutputPlan) -> Result<BackendSession, BackendError> {
        Ok(BackendSession {
            repo_root: repo_root.to_path_buf(),
            plan: plan.clone(),
        })
    }

    fn apply(
        &self,
        session: &mut BackendSession,
        outputs: &[RenderedOutput],
    ) -> Result<ApplyReport, BackendError> {
        let mut report = ApplyReport::default();

        // Index planned outputs by path for policy lookup.
        let mut planned_by_path: BTreeMap<&str, &crate::outputs::PlannedOutput> = BTreeMap::new();
        for p in &session.plan.outputs {
            planned_by_path.insert(p.path.as_str(), p);
        }

        for out in outputs {
            let planned = planned_by_path
                .get(out.path.as_str())
                .ok_or_else(|| BackendError::Unsupported {
                    message: format!(
                        "rendered output not present in plan: {}",
                        out.path.as_str()
                    ),
                })?;

            let dest = session.repo_root.join(out.path.as_str());

            let mode = planned
                .write_policy
                .mode
                .unwrap_or(crate::model::WriteMode::IfGenerated);

            if mode == crate::model::WriteMode::Never {
                report.skipped.push(out.path.clone());
                continue;
            }

            if mode == crate::model::WriteMode::IfGenerated {
                // If a file exists, it must be generated by agents and not drifted.
                if dest.exists() {
                    let existing = fsutil::read_to_string(&dest)?;
                    let stamp = parse_stamp(&existing);
                    let managed_by_agents = stamp.as_ref().is_some_and(|s| s.meta.generator == "agents");
                    if !managed_by_agents {
                        report.conflicts.push(out.path.clone());
                        report.conflict_details.push(ConflictDetail {
                            path: out.path.clone(),
                            reason: ConflictReason::Unmanaged,
                            message: "refusing to overwrite unmanaged file (writePolicy=if_generated)"
                                .to_string(),
                            hints: vec![
                                format!("hint: run `agents diff --agent {}`", session.plan.agent_id),
                                "hint: change output.writePolicy.mode to `always` to force overwrite"
                                    .to_string(),
                            ],
                        });
                        continue;
                    }

                    if out.drift_status == crate::stamps::DriftStatus::Drifted {
                        report.conflicts.push(out.path.clone());
                        report.conflict_details.push(ConflictDetail {
                            path: out.path.clone(),
                            reason: ConflictReason::Drifted,
                            message: "refusing to overwrite drifted generated file (writePolicy=if_generated)"
                                .to_string(),
                            hints: vec![
                                format!("hint: run `agents diff --agent {}`", session.plan.agent_id),
                                "hint: reconcile manual edits or change output.writePolicy.mode"
                                    .to_string(),
                            ],
                        });
                        continue;
                    }
                }
            }

            // `always` overwrites unconditionally; `if_generated` reaches here only when safe.
            let bytes = normalize_bytes_for_write(&dest, &out.bytes, Some(planned.format));
            fsutil::atomic_write(&dest, &bytes)?;
            report.written.push(out.path.clone());
        }

        Ok(report)
    }
}

fn normalize_bytes_for_write(_path: &PathBuf, bytes: &[u8], format: Option<OutputFormat>) -> Vec<u8> {
    let format = format.unwrap_or(OutputFormat::Text);
    if !is_text_format(format) {
        return bytes.to_vec();
    }

    // Best-effort: if content is UTF-8, normalize newlines + trailing newline.
    let Ok(s) = std::str::from_utf8(bytes) else {
        return bytes.to_vec();
    };

    let normalized = s.replace("\r\n", "\n");
    fsutil::ensure_trailing_newline(&normalized).into_bytes()
}

fn is_text_format(format: OutputFormat) -> bool {
    match format {
        OutputFormat::Text | OutputFormat::Md | OutputFormat::Yaml | OutputFormat::Json | OutputFormat::Jsonc => true,
    }
}
