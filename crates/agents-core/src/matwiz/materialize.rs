use std::collections::BTreeMap;
use std::path::{Path, PathBuf};

use crate::fsutil;
use crate::model::OutputFormat;
use crate::outputs::OutputPlan;
use crate::stamps::parse_stamp;

use super::{
    ApplyReport, Backend, BackendError, BackendSession, ConflictDetail, ConflictReason,
    RenderedOutput,
};

#[derive(Debug, Default, Clone)]
pub struct MaterializeBackend;

impl Backend for MaterializeBackend {
    fn prepare(&self, repo_root: &Path, plan: &OutputPlan) -> Result<BackendSession, BackendError> {
        Ok(BackendSession {
            repo_root: repo_root.to_path_buf(),
            plan: plan.clone(),
        })
    }

    fn apply(
        &self,
        session: &mut BackendSession,
        outputs: &[RenderedOutput],
    ) -> Result<ApplyReport, BackendError> {
        let mut report = ApplyReport::default();

        // Index planned outputs by path for policy lookup.
        let mut planned_by_path: BTreeMap<&str, &crate::outputs::PlannedOutput> = BTreeMap::new();
        for p in &session.plan.outputs {
            planned_by_path.insert(p.path.as_str(), p);
        }

        for out in outputs {
            let planned = planned_by_path.get(out.path.as_str()).ok_or_else(|| {
                BackendError::Unsupported {
                    message: format!("rendered output not present in plan: {}", out.path.as_str()),
                }
            })?;

            let dest = session.repo_root.join(out.path.as_str());

            let mode = planned
                .write_policy
                .mode
                .unwrap_or(crate::model::WriteMode::IfGenerated);

            if mode == crate::model::WriteMode::Never {
                report.skipped.push(out.path.clone());
                continue;
            }

            if mode == crate::model::WriteMode::IfGenerated {
                // If a file exists, it must be generated by agents and not drifted.
                if dest.exists() {
                    let existing = fsutil::read_to_string(&dest)?;
                    let stamp = parse_stamp(&existing);
                    let managed_by_agents =
                        stamp.as_ref().is_some_and(|s| s.meta.generator == "agents");
                    if !managed_by_agents {
                        report.conflicts.push(out.path.clone());
                        report.conflict_details.push(ConflictDetail {
                            path: out.path.clone(),
                            reason: ConflictReason::Unmanaged,
                            message: "refusing to overwrite unmanaged file (writePolicy=if_generated)"
                                .to_string(),
                            hints: vec![
                                format!("hint: run `agents diff --agent {}`", session.plan.agent_id),
                                "hint: change output.writePolicy.mode to `always` to force overwrite"
                                    .to_string(),
                            ],
                        });
                        continue;
                    }

                    if out.drift_status == crate::stamps::DriftStatus::Drifted {
                        report.conflicts.push(out.path.clone());
                        report.conflict_details.push(ConflictDetail {
                            path: out.path.clone(),
                            reason: ConflictReason::Drifted,
                            message: "refusing to overwrite drifted generated file (writePolicy=if_generated)"
                                .to_string(),
                            hints: vec![
                                format!("hint: run `agents diff --agent {}`", session.plan.agent_id),
                                "hint: reconcile manual edits or change output.writePolicy.mode"
                                    .to_string(),
                            ],
                        });
                        continue;
                    }
                }
            }

            // `always` overwrites unconditionally; `if_generated` reaches here only when safe.
            let bytes = normalize_bytes_for_write(&dest, &out.bytes, Some(planned.format));
            fsutil::atomic_write(&dest, &bytes)?;
            // Intentionally do not set executable bits or other platform-specific permissions.
            report.written.push(out.path.clone());
        }

        // Optional: update .gitignore entries for outputs that request it.
        update_gitignore_for_written(session, &planned_by_path, &mut report)?;

        Ok(report)
    }
}

fn update_gitignore_for_written(
    session: &BackendSession,
    planned_by_path: &BTreeMap<&str, &crate::outputs::PlannedOutput>,
    report: &mut ApplyReport,
) -> Result<(), BackendError> {
    let mut entries: Vec<String> = vec![];

    for p in &report.written {
        if let Some(planned) = planned_by_path.get(p.as_str()) {
            if planned.write_policy.gitignore {
                entries.push(p.as_str().to_string());
            }
        }
    }

    entries.sort();
    entries.dedup();

    if entries.is_empty() {
        return Ok(());
    }

    let gitignore_path = session.repo_root.join(".gitignore");
    if !gitignore_path.is_file() {
        // Default safe: do not create a new .gitignore.
        return Ok(());
    }

    let existing = fsutil::read_to_string(&gitignore_path)?;
    if !has_agents_gitignore_block(&existing) {
        // Default safe: do not modify user-managed .gitignore.
        return Ok(());
    }

    let updated = replace_agents_gitignore_block(&existing, &entries);
    fsutil::atomic_write(&gitignore_path, updated.as_bytes())?;

    // Track .gitignore write as a written path for reporting consumers.
    if let Ok(rp) = fsutil::repo_relpath(&session.repo_root, &gitignore_path) {
        report.written.push(rp);
    }

    Ok(())
}

fn has_agents_gitignore_block(existing: &str) -> bool {
    const BEGIN: &str = "# BEGIN agents (generated)";
    const END: &str = "# END agents";
    existing.lines().any(|l| l.trim_end() == BEGIN) && existing.lines().any(|l| l.trim_end() == END)
}

fn replace_agents_gitignore_block(existing: &str, entries: &[String]) -> String {
    const BEGIN: &str = "# BEGIN agents (generated)";
    const END: &str = "# END agents";

    let existing = existing.replace("\r\n", "\n");
    let mut lines: Vec<&str> = existing.lines().collect();

    // Remove any existing managed block.
    if let Some(start) = lines.iter().position(|l| l.trim_end() == BEGIN) {
        if let Some(end_rel) = lines[start..].iter().position(|l| l.trim_end() == END) {
            let end = start + end_rel;
            // Remove from start..=end
            lines.drain(start..=end);
            // Also remove a single trailing blank line if present.
            while start < lines.len() && lines[start].trim().is_empty() {
                lines.remove(start);
                break;
            }
        }
    }

    let mut out = lines.join("\n");
    out = out.trim_end().to_string();
    if !out.is_empty() {
        out.push('\n');
        out.push('\n');
    }

    out.push_str(BEGIN);
    out.push('\n');
    for e in entries {
        out.push_str(e);
        out.push('\n');
    }
    out.push_str(END);
    out.push('\n');

    out
}

fn normalize_bytes_for_write(
    _path: &PathBuf,
    bytes: &[u8],
    format: Option<OutputFormat>,
) -> Vec<u8> {
    let format = format.unwrap_or(OutputFormat::Text);
    if !is_text_format(format) {
        return bytes.to_vec();
    }

    // Best-effort: if content is UTF-8, normalize newlines + trailing newline.
    let Ok(s) = std::str::from_utf8(bytes) else {
        return bytes.to_vec();
    };

    let normalized = s.replace("\r\n", "\n");
    fsutil::ensure_trailing_newline(&normalized).into_bytes()
}

fn is_text_format(format: OutputFormat) -> bool {
    match format {
        OutputFormat::Text
        | OutputFormat::Md
        | OutputFormat::Yaml
        | OutputFormat::Json
        | OutputFormat::Jsonc => true,
    }
}
