# Architecture: agents (Rust CLI)

## Purpose
`agents` is a Rust CLI that treats `.agents/` as the canonical, version-controlled configuration surface for AI coding agents and projects that configuration into each agent's native files (materialized on disk or virtually projected at runtime).

The CLI must be:
- Deterministic: same inputs produce byte-identical outputs.
- Explainable: every generated byte can be traced to sources.
- Safe-by-default: policy evaluation is conservative; destructive actions require explicit confirmation.
- Cross-platform: macOS/Linux/Windows.

## High-level system model
### Core pipeline
All commands build on the same pipeline; individual commands stop at different stages.

1. Discover inputs
   - Repo canonical: `.agents/**`
   - Optional user overlay: `~/.agents/**` (configurable)
   - Optional repo state: `.agents/state/state.yaml` (gitignored)
   - CLI overrides: `--mode`, `--profile`, `--policy`, `--scope`, `--backend`, `--agent`
2. Load + validate
   - Parse YAML/Markdown frontmatter into typed structs.
   - Validate with JSON Schemas from `.agents/schemas/**`.
3. Resolve effective configuration
   - Determine scopes matched for a target path (or repo root).
   - Compute effective mode/policy/profile/backend and enabled skills.
   - Compose prompt sources (base/project/snippets) applying policy redaction.
4. Build a generation plan
   - Select adapter(s) and outputs based on `--agent`, profile, backend.
   - Plan collisions by logical `surface` and physical `path`.
   - Compute drift metadata + stamping plan.
5. Render outputs
   - Handlebars templates or other renderer types (concat/copy/json_merge).
   - Stable ordering and stable serialization.
6. Apply backend
   - `preview`: write to temp dir only.
   - `diff`: compare planned outputs vs materialized files.
   - `sync`: materialize or prepare VFS projection.
   - `run`: start backend + skills runtime, then exec agent.
7. Explainability
   - Maintain a source map per output (for `agents explain`).

## Rust project layout
Use a small workspace with clear boundaries:

- `crates/agents-cli` (bin)
  - Clap command parsing, UX output, confirmation prompts.
  - Delegates to `agents-core` for all logic.
- `crates/agents-core` (lib)
  - Data model, resolution, rendering, planning, drift logic.
- `crates/agents-backend` (lib)
  - Backend implementations: `materialize`, `vfs_container`.
- `crates/agents-adapter` (lib)
  - Adapter loading + renderer dispatch; shared-surface generator.
- `crates/agents-testutil` (lib, dev-dep)
  - Golden fixtures harness and snapshot helpers.

Key crates (expected): `clap`, `serde`, `serde_yaml`, `serde_json`, `toml`, `handlebars`, `globset`, `walkdir`, `sha2`, `tempfile`, `thiserror` (or `anyhow`+`miette`), `tracing`.

## Data model
### Canonical entities
- Manifest: `.agents/manifest.yaml`
  - Defaults and enabled sets.
- Policies: `.agents/policies/*.yaml`
- Skills: `.agents/skills/<id>/skill.yaml`
- Modes: `.agents/modes/*.md` with optional YAML frontmatter (mode metadata) and Markdown body (human-readable behavioral guidance).
- Scopes: `.agents/scopes/*.yaml` with `applyTo` glob patterns.
- Profiles: `.agents/profiles/*.yaml` (profile-specific defaults/overrides; treated as part of resolution).
- Adapters: `.agents/adapters/<agentId>/adapter.yaml` + `templates/**`.
- State: `.agents/state/state.yaml` (non-committed).

### Parsing strategy
- YAML: `serde_yaml` into typed structs; enforce `additionalProperties: false` by schema validation.
- Markdown: parse YAML frontmatter if present; treat body as Markdown text.
- JSON/JSONC outputs: generate via stable serializer (JSON) and optionally wrap with deterministic comment stamp for JSONC.

### Stable serialization and ordering
- Use `BTreeMap` for map fields that are serialized.
- Sort lists in generated outputs where ordering is not semantically meaningful.
- Normalize newlines to `\n` and end files with a single trailing newline.

## Resolution model
### Inputs and precedence
Implement PRD precedence exactly (highest wins):
1. CLI flags/env overrides
2. Repo `.agents` base
3. Repo scopes (most specific match wins; ties resolved deterministically)
4. User overlay (if enabled)

Notes:
- Mode/policy IDs must exist in enabled sets; unknown IDs are an error.
- "Deny beats allow" applies to policy fields (paths, exec/network/mcp allow/deny).

### Scope matching and specificity
- `applyTo` patterns are evaluated with `globset` against repo-relative paths.
- Specificity score:
  - More path segments and fewer wildcards score higher.
  - Break ties with explicit `priority` (higher wins).
  - Final tie-breaker: lexicographic `scope.id`.

### Merge semantics
- Deep merge for objects.
- For policy allow/deny arrays:
  - Union values, then apply deny precedence in evaluation.
- For singletons:
  - Conflicts are errors (default) or warnings if manifest allows.

## Prompt composition
### Sources
- `.agents/prompts/base.md`
- `.agents/prompts/project.md`
- `.agents/prompts/snippets/*.md` selected by mode and scopes

### Redaction
Before any prompt text is injected into generated instruction surfaces:
- Apply `policy.paths.redact` globs.
- If a referenced file is redacted, replace content with a deterministic placeholder (do not include file contents).

## Adapter system
### Adapter loading
An adapter is defined by:
- `adapter.yaml`: outputs, renderers, collision policy, drift behavior.
- `templates/**`: Handlebars templates.

Adapters are loaded from `.agents/adapters/**` and filtered by manifest `enabled.adapters`.

### Renderers
Renderer types from the PRD:
- `template`: Handlebars template rendered with a standard context.
- `concat`: deterministic concatenation of source fragments.
- `copy`: copy an existing canonical file into output.
- `json_merge`: deep merge JSON objects then serialize deterministically.

### Template engine
Use `handlebars` crate with strict mode enabled:
- Missing variables are errors.
- Partials supported.

Required helpers (v1):
- `indent(text, n)`
- `join(list, sep)`
- `toJson(obj)` / `toJsonc(obj)` (stable ordering)
- `toYaml(obj)` (stable ordering)
- `frontmatter(obj)`
- `generatedStamp(meta)`

### Standard render context
Render context is a single JSON-like struct (serde) with stable field names:
- `effective.mode`, `effective.policy`, `effective.skills`, `effective.prompts`
- `profile`, `scopesMatched`
- `generation.stamp`, `adapter.agentId`

### Shared surfaces and collisions
Treat collisions on two axes:
- Logical `surface` (e.g., `shared:AGENTS.md`)
- Physical `path`

Planning stage detects collisions and applies the declared policy:
- `error`: fail.
- `overwrite`: only allowed if output is stamped/owned by the same generator.
- `merge`: deterministic concatenation with stable ordering.
- `shared_owner`: only a single designated owner (manifest `defaults.sharedSurfacesOwner`) may emit this surface.

## Output lifecycle
### Stamping
Every generated artifact includes a deterministic stamp:
- Includes: generator id, adapter id, manifest specVersion, effective mode/profile, and a content hash.
- Stamps are placed via:
  - `comment` for text/Markdown
  - `frontmatter` for Markdown where appropriate
  - `json_field` for JSON outputs

### Drift detection
Default drift method: sha256.
- A file is "generated" if it contains a valid stamp.
- Drift exists if stamp hash differs from recomputed hash.

### Cleaning
`agents clean` only deletes files that:
- are stamped as generated by this tool, and
- match adapter-declared output paths.

## Backends
### materialize
Writes outputs to the repo filesystem.
- Enforces adapter `writePolicy`:
  - `always`: overwrite.
  - `if_generated`: overwrite only if already stamped.
  - `never`: do not write (used for preview-only outputs).
- Optionally updates `.gitignore` entries when `writePolicy.gitignore=true`.

### vfs_container
Runs the target agent in a container with projected outputs.

Implementation approach (portable and simple):
- Generate outputs into a temp directory on the host.
- Start container with:
  - repo bind-mounted to `/workspace` (read-only by default)
  - temp output dir bind-mounted over specific target paths (or mounted as `/__agents_out` and then copied into a writable layer inside the container).
- Set container working directory to `/workspace`.

Policy enforcement (best-effort):
- Exec/network restrictions enforced by the wrapper where possible (timeouts; denylist patterns).
- Filesystem write restrictions enforced by container mount options where possible (ro mounts) and by refusing to materialize.

Future: `vfs_mount` can be introduced as a third backend without changing planning/rendering.

## Skills runtime
### Activation modes
- `instruction_only`: contributes prompt/snippet content only.
- `mcp_tool`: CLI launches MCP servers per skill definition and exposes endpoints to the agent.
- `cli_shim`: skill assets are made available in the runtime environment (container PATH or mounted scripts).

### Assembly
When `agents run` is invoked:
- Compute enabled skills.
- Validate policy allows MCP/exec/network required by each skill.
- Start MCP servers (if any), tracking PIDs and logs.
- Provide generated environment variables/config snippets to the agent via adapter outputs or backend injection.

## CLI command architecture
### Command to pipeline mapping
- `init`: create `.agents/` from a preset template set.
- `validate`: load + schema validation + basic referential integrity.
- `status`: resolve and print effective mode/profile/scopes/policy/skills/backend/agent.
- `set-mode`: write `.agents/state/state.yaml` and optionally trigger `sync`.
- `preview`: plan + render to temp dir and print output list.
- `diff`: plan + render to temp dir; diff against materialized outputs.
- `sync`: plan + render; apply backend.
- `run`: resolve + render; start backend and exec agent.
- `doctor`: validate + drift + collision checks; optionally fix safe issues.
- `clean`: delete generated outputs.
- `import`: convert agent-native config back into `.agents` artifacts (explicit).
- `explain`: print source map for a generated path.
- `compat`: print adapter/backends/policy coverage matrix.
- `test adapters`: golden fixture runner.

### Error handling and UX
- Use structured errors with context (file path, schema name, adapter output path).
- Keep stderr for errors; stdout for command output.
- Confirmations are centralized and keyed by action (delete/overwrite/push/rebase/etc.).

## Testing strategy
- Unit tests: merge semantics, scope specificity, stamping, stable serialization.
- Integration tests:
  - Schema validation on fixtures.
  - End-to-end plan+render on fixtures.
- Adapter golden tests:
  - Render deterministic outputs from fixture repos and compare snapshots.
  - Required CI gate for `.agents/adapters/**` changes.

## Observability
- `tracing` for debug logs; default to quiet output.
- `--json` output mode (future) for CI-friendly diagnostics.
