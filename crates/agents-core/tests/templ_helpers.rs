use agents_core::templ::{RenderContext, TemplateEngine};

fn minimal_ctx() -> RenderContext {
    agents_core::templ::RenderContext {
        effective: agents_core::templ::EffectiveCtx {
            mode: agents_core::templ::EffectiveModeCtx {
                frontmatter: None,
                body: "mode body".to_string(),
            },
            policy: agents_core::model::Policy {
                id: "p".to_string(),
                description: "d".to_string(),
                capabilities: agents_core::model::Capabilities {
                    filesystem: None,
                    exec: None,
                    network: None,
                    mcp: None,
                },
                paths: agents_core::model::Paths {
                    allow: vec![],
                    deny: vec![],
                    redact: vec![],
                },
                confirmations: agents_core::model::Confirmations {
                    required_for: vec![],
                },
                limits: None,
                x: None,
            },
            skills: agents_core::templ::EffectiveSkillsCtx {
                ids: vec!["a".to_string(), "b".to_string()],
                summaries: vec![],
            },
            prompts: agents_core::prompts::EffectivePrompts {
                base_md: "Base".to_string(),
                project_md: "Project".to_string(),
                snippets: vec![],
                composed_md: "Base\n\nProject\n".to_string(),
            },
        },
        backend: agents_core::model::BackendKind::VfsContainer,
        profile: None,
        scopes_matched: vec!["s".to_string()],
        generation: agents_core::templ::GenerationCtx {
            stamp: agents_core::templ::GenerationStampCtx {
                generator: "agents".to_string(),
                adapter_agent_id: "x".to_string(),
                mode: "default".to_string(),
                profile: None,
            },
        },
        adapter: agents_core::templ::AdapterCtx {
            agent_id: "x".to_string(),
        },
        x: None,
    }
}

#[test]
fn helper_indent_is_deterministic() {
    let engine = TemplateEngine::new();
    let ctx = minimal_ctx();
    let out = engine
        .render_inline("{{indent \"a\\nb\" 2}}", &ctx)
        .unwrap();
    assert_eq!(out, "  a\n  b\n");
}

#[test]
fn helper_join_is_deterministic() {
    let engine = TemplateEngine::new();
    let ctx = minimal_ctx();
    let out = engine
        .render_inline("{{join effective.skills.ids \",\"}}", &ctx)
        .unwrap();
    assert_eq!(out, "a,b\n");
}

#[test]
fn helper_to_json_is_stable() {
    let engine = TemplateEngine::new();
    let ctx = minimal_ctx();
    let out = engine.render_inline("{{toJson adapter}}", &ctx).unwrap();
    assert!(out.contains("\"agentId\""));
}

#[test]
fn helper_frontmatter_is_stable() {
    let engine = TemplateEngine::new();
    let ctx = minimal_ctx();
    let out = engine
        .render_inline("{{frontmatter adapter}}", &ctx)
        .unwrap();

    assert!(out.starts_with("---\n"));
    assert!(out.contains("agentId"));
    assert!(out.ends_with("---\n"));
}

#[test]
fn helper_generated_stamp_is_stable() {
    let engine = TemplateEngine::new();
    let ctx = minimal_ctx();
    let out = engine
        .render_inline("{{generatedStamp generation.stamp}}", &ctx)
        .unwrap();

    assert!(out.starts_with("<!-- @generated by agents: "));
    assert!(out.ends_with(" -->\n"));
}

#[test]
fn render_is_deterministic_across_runs() {
    let engine = TemplateEngine::new();
    let ctx = minimal_ctx();

    let a = engine
        .render_inline("mode={{effective.mode.body}}", &ctx)
        .unwrap();
    let b = engine
        .render_inline("mode={{effective.mode.body}}", &ctx)
        .unwrap();

    assert_eq!(a, b);
}
