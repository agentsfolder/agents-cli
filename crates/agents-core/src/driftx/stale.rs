use std::collections::BTreeSet;
use std::path::{Component, Path};

use walkdir::WalkDir;

use crate::stamps::parse_stamp;

use super::{DiffEntry, DiffKind, DriftxError};

pub fn detect_stale_generated(
    repo_root: &Path,
    adapter_agent_id: &str,
    planned_paths: &BTreeSet<String>,
) -> Result<Vec<DiffEntry>, DriftxError> {
    let mut out = vec![];

    for entry in WalkDir::new(repo_root)
        .follow_links(false)
        .into_iter()
        .filter_entry(|e| !is_skipped_dir(e.path()))
    {
        let entry = entry.map_err(|e| DriftxError::Walkdir(e.to_string()))?;
        if !entry.file_type().is_file() {
            continue;
        }

        // Skip repo-internal stuff.
        if is_skipped_file(entry.path()) {
            continue;
        }

        let abs = entry.path();
        let rel = abs.strip_prefix(repo_root).unwrap_or(abs);
        let rel_s = rel.to_string_lossy().replace('\\', "/");

        if planned_paths.contains(&rel_s) {
            continue;
        }

        // Only detect deletion for files stamped as generated by agents AND matching adapter.
        let bytes = std::fs::read(abs).map_err(|e| crate::fsutil::FsError::Io {
            path: abs.to_path_buf(),
            source: e,
        })?;

        let content = match String::from_utf8(bytes) {
            Ok(s) => s.replace("\r\n", "\n"),
            Err(_) => continue,
        };

        let Some(stamp) = parse_stamp(&content) else {
            continue;
        };

        if stamp.meta.generator != "agents" {
            continue;
        }

        if stamp.meta.adapter_agent_id != adapter_agent_id {
            continue;
        }

        out.push(DiffEntry {
            path: rel_s,
            kind: DiffKind::Delete,
            drift: None,
            details: Some("generated output exists but is no longer planned".to_string()),
            unified_diff: None,
        });
    }

    // Ensure deterministic ordering.
    out.sort_by(|a, b| a.path.cmp(&b.path));
    Ok(out)
}

fn is_skipped_dir(path: &Path) -> bool {
    // Skip .git and .agents by default to avoid scanning internal config.
    if let Some(name) = path.file_name().and_then(|n| n.to_str()) {
        if name == ".git" || name == ".agents" {
            return true;
        }
    }

    false
}

fn is_skipped_file(path: &Path) -> bool {
    // Skip anything under .git or .agents.
    for comp in path.components() {
        if let Component::Normal(os) = comp {
            if os == ".git" || os == ".agents" {
                return true;
            }
        }
    }

    false
}
